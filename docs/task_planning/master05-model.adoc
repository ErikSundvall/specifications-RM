= Task Planning Model

== Overview

The following figure shows the `rm.composition.task_planning` package, including its relationships to existing classes.

[.text-center]
.rm.composition.task_planning package
image::{uml_export_dir}/diagrams/RM-composition.task_planning.svg[id=rm_composition_task_planning, align="center"]

=== Compositions and Versioning

In this model a `TASK_LIST` inherits from `CONTENT_ITEM`, the abstract type of the `_content_` attribute of a `COMPOSITION`. A `TASK_LIST` and its constituent `TASKs` are assumed to be created within a singsle dedicated `COMPOSITION` which is re-versioned as changes are made to its contents. The causes of change include:

* changes to the definition, due to error correction and / or extension of the lookahead planning window;
* updates to Task lifecycle states at execution time;
* additions to the execution history, corresponding to each Task or List level event, including completion or abandonment of the Task list.

As the `TASK_LIST` gets progressively built and executed over time, its owning `COMPOSITION` will undergo numerous changes, corresponding both to changes to the plan, and also execution of the actions performed to fulfill it. Typically only the former will generate new committed versions to the EHR, whereas the latter will most likely only be used by the workflow application during execution of the Task List. How changes to Task List are versioned and added to the EHR (or not) can be handled flexibly according to local needs.

=== Basic Semantics of a Task List

In the model, a Task List is specified by a number of key attributes, following the design principles described above, namely:

* `_subject_`: the subject of the work (i.e. 'case' in workflw parlance), typically a single patient;
* `_principal_performer_`: a definition of the responsible performer, normall in terms of role plus function;
* `_description_`: natural language specification of what the Task List is for;
* `_care_plan_`: a reference to a driving Care Plan, if any exists;
* `_guideline_id_`, `_care_pathway_`: references to a guideline and/or care pathway.
* `_training_level_`: a value that can be used to filter out fine-grained Task Lists in a chained structure only of interest to trainees;

These are described in more detail below.

=== Containment Structure

The set of Tasks in Task List is represented within a containment structure created using instances of the `TASK_GROUP` type. This provides a way of grouping Tasks that will be executed collectively on the same basis, via the `_execution_type_` attribute, which may be set to `sequential` or `parallel`. This includes the top-level set of Tasks. A `TASK_GROUP` instance is treated as a member of its enclosing `TASK_GROUP` in the same way as constituent `TASK` instances, and shares with the latter attributes for Task description, timing, and conditions for execution.

The following illustrates the Task group structure.

[.text-center]
.Task grouping
image::diagrams/task_grouping.svg[id=task_grouping, align="center", width=25%]

=== Basic Semantics of a Task

The important semantics of the Task concept in the model are specified in the `TASK_LIST_ITEM` class, with further specifics appearing in the `TASK_GROUP` and `TASK` descendants. Key attributes of a `TASK_LIST_ITEM` include:

* `_description_`: natural language specification of what the Task is;
* `_preconditions_`, `_wait_conditions_`, `_execution_time_`: operational conditions for determining if a Task is ready for execution by a performer;
* `_indications_`: clinical conditions for the Task being applicable;
* `_notifications_`: specfication of coordinating notifications to be sent to other performer / Task contexts;
* `_costing_data_`: fine-grained data to enable cost determination of work performed;
* `_other_participations_`: participations other than the principal performer.

Each of these are explained in detail below.

=== Task Types

As mentioned in the requirements section, the granularity of a Task can be variable from one healthcare context to another, as per the cannulation example. This leads to two possibilities:

* _atomic representation_: a Task that may in reality consist of several fine-grained steps may be represented within a Task List as a single Task, on the assumption that the performer will correctly determine how to execute it;
* _reference to composite representation_: the currently executing Task List may refer out to another Task List containing numerous sub-tasks representing the detailed work of a particular Task in the original list.

The model described here thus makes no _a priori_ assumptions about granularity of representation of a given real-world task, and both representations are possible. This first kind is thus represented as an instance of the class `DEFINED_TASK`, while the second is achieved with the use of an `EXTERNAL_TASK` which refers out to another `TASK_LIST` to be executed by the same performer.

The second feature gives rise to the possibility of a hierarchy of linked Task Lists, with each successive member in the chain representing a more detailed form of a given real world task. This can be visualised as follows.

[.text-center]
.Task list linking
image::diagrams/task_linking.svg[id=task_linking, align="center", width=70%]

A structure like the above may be used differently by performers of differing training levels - since each `EXTERNAL_TASK` has its own `_description_`, an expert user may reqire no further list of steps, but a trainee might make use of the full hierarchical structure. The `_training_level_` attribute on `TASK_LIST` can be used to control this. A higher value corresponds to a lower level of expertise, and different values can be set on different linked `TASK_LISTs`. The workflow application may treat different users as being of different training levels, in which case Task Lists of higher training levels can be hidden. The default value of `_training_level_` is 0.

=== Task Definition

The job of specifying the work to be done in a concrete (i.e. inline) Task definition is achieved via the `DEFINED_TASK` atttribute `_prototype_`, of type `ENTRY`, which enables a Task to be specified in terms of an instance of a descendant of the `ENTRY` class. This is typically an `ACTION` instance but could be an `OBSERVATION`, `ADMIN_ENTRY` or other descendant.

The attribute is called 'prototype' because the target Entry instance is understood as a partially populated, prototype 'planning time' copy of an Entry that will actually be created when the Task is actually performed. For example, a Task List for administering medication at 8 hourly intervals over a number of days could consist of a number of `DEFINED_TASKs`, each having a protoype of an `ACTION` instance based on the `openEHR-EHR-ACTION.medication.v1` archetype or a templated version thereof. Each such instance would contain the structured description of the medication administration and time, and when the administration was actually performed, an `ACTION` instance would be created from the prototype, modified to reflect any divergence from the planned form of the Task, and committed to the EHR in the normal way.

The following illustrates Task definitions using prototypes.

[.text-center]
.Task definition
image::diagrams/task_definition.svg[id=task_definition, align="center", width=35%]

Assuming that the Task List is archetyped in the same way as Entries and other elements of the EHR, this scheme supports various modes of design-time specification. The `_prototype_` attribute in a `TASK_LIST` archetype will usually be represented by an archetype slot or external reference, which specifies identifiers of permitted archetypes (or templates) of the target type, i.e. `ACTION` or other Entry. This can be used in various ways, as follows:

* {openehr_am_adl2}#_external_references[external reference]: specifies a fixed archetype identifier which will be substituted in the templated form of the Task List. This has the effect of creating `ACTION` or other prototype instances in the `TASK_LIST` structure;
* {openehr_am_adl2}#_archetype_slots[archetype slot]: specified using a slot constraint that is satisfied by one or more archetypes that may be specified by a template, or left open until runtime.

In the latter case, the slot may be filled in the Task List template with an `ACTION` or other Entry archetype, allowing the Tasks to be fully specified inline as in the external reference case. Alternatively, it may be left unresolved, which would allow the workflow application to choose the exact Task definition archetype at runtime.

One reason to allow a Task to contain a `_prototype_` reference that remains unresolved until runtime is if the Task represents the act of making an observation, for example, taking a blood pressure. In such cases, no prototype at all may be needed, and the Task `_description_` attribute (inherited from `TASK_LIST_ITEM`) may be sufficient information for the performer. On the other hand, a prototype `OBSERVATION` could be specified in the `TASK_LIST` template, which defines a particular form of the observation, e.g. a blood pressure which only records systolic pressure and cuff size.

To allow further flexibility, The multiplicity of the `_prototype_` attribute is unlimited, to allow for the possibility of one Task being prototyped by more than one Entry instance, e.g. an `ACTION` and an `OBSERVATION`, two `ADMIN_ENTRY` instances and so on.

A related question has to do with the granularity of Tasks with respect to the granularity of resulting `ACTION`, `OBSERVATION` and other EHR Entries. The model makes the assumption that one Task, if performed, refers to and is documented by one `ACTION` or other archetyped `ENTRY`.

[.tbd]
ISSUE-task-entry-corr: the alternative seems to be to allow a Task to correspond to e.g. a whole Composition template, where the `COMPOSITION` contains a number of e.g. `ACTIONs` or `OBSERVATIONs`. Problems I see with this: a) who knows what is in the Composition template? It may change over time; b) what if only some of the items in the Composition template can be done? Is the Task half complete? Or should the performer not do any of it?

=== Coordinated Teamwork

Performing teamwork in a coordinated fashion with task planning support necessarily requires multiple Task Lists - one for each actor, and a means of coordination among them. This is achieved by the use of two special types of object that can be attached to a `TASK_LIST_ITEM` (i.e. any Task group or Task):

* _notifications_: notifications that should be issued on a specific Task execution event, e.g. commencement, completion etc;
* _wait_conditions_: conditions that specify external Task events to wait for, i.e. completions or other events performed by other actors in related Task Lists.

These two attributes enable both directions of communication between any two actors working in a coordinated workflow to be expressed. The following illustrates, using the example of an acute stroke management care process.

[.text-center]
.Task coordination
image::diagrams/task_coordination.svg[id=task_coordination, align="center", width=70%]

=== Class Descriptions

include::{uml_export_dir}/classes/task_list.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_participation.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/planned_event_time.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_list_item.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/execution_type.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/external_task.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/defined_task.adoc[leveloffset=+1]

== Conditions for Task Execution

According to the model, a Task is available for execution by a performer if:

* its preconditions, if any, are met;
* it is not waiting on any external Task being (i.e. being performed by another actor) to complete;
* previous Tasks in the same Task List, if any, are in a terminal lifecycle state, i.e. have been completed, cancelled or aborted.

The first two characteristics are represented respectively by the `TASK_LIST_ITEM` attributes `_preconditions_: TASK_PRECONDITION` and `_wait_conditions_: TASL_WAIT_CONDITION`.

[.tbd]
TBD: To be continued

`TASK_LIST_ITEM` also includes an optional `_execution_time_` attribute which indicates the intended time of execution. This time is understood as a guide, enabling Tasks to be placed on a schedule timeline, and is useful for time-dependent activities such as medication administration. A performer may execute the Task earlier or later than the indicated time.

=== Class Descriptions

include::{uml_export_dir}/classes/task_precondition.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_wait_condition.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_notification.adoc[leveloffset=+1]

== Task Execution Tracking

Following the design principle of separation of Task definition and execution state, the model represents the history and state of execution of a Task List as a separate high-level part of the model, via the `_execution_history_` attribute of `TASK_LIST`. The execution of a Task List is represented in terms of a state lifecycle model for each Task, and transitions over time between the states, along with associated information.

=== Task Lifecycle

Each `TASK` in a `TASK_LIST` has a lifecycle consisting of various states it may pass through in time. The lifecycle is simple, since it only has to take account of the states a Task - understood as a task _definition_ - can pass through, with documentation of the Task execution occurring in the form of separate openEHR `ACTION` or other Entry objects. The states are as follows:

* _initial_: initial pseudo-state, not used in operation;
* _planned_: defined, but not available for execution;
* _available_: available for execution, due to previous Tasks having been performed;
* _cancelled_: cancelled prior to being performed;
* _completed_: performed to completion;
* _aborted_: execution was commenced but stopped before completion.

The corresponding state machine is shown below.

[.text-center]
.Task lifecycle state machine
image::{uml_export_dir}/diagrams/RM-TaskStateMachine.svg[id=task_state_machine, align="center", width=60%]

The state for each Task is recorded in the `_lifecycle_state_` attribute. 

NOTE: This is the only execution time related attribute in the Task List definition. If it is necessary to record the final lifecycle states of Tasks in a completed Task List, the `TASK_LIST` will need to be re-committed to the EHR as a new version in order to achieve this.

Since a Task List is a hierarchical structure consisting of one or more Task Groups, a way of rolling up Task state is needed. The following algorithm is used to compute the effective lifecycle state of a `TASK_GROUP` from the set of states of its members (which may include other `TASK_GROUPs`).

[source, java]
--------
//
// Infer the state of a collection whose members have states in sourceStates.
// The order of if/else evaluation determines the correct result.
//
TaskState inferredState (Set<TaskState> sourceStates) {
    TaskState inferredStateValue;
    if (sourceStates.contains(Available))
        return Available;
    else if (sourceStates.contains(Planned))
        return Planned;
    else if (sourceStates.contains(Completed))
        return Completed;
    else if (sourceStates.contains(Aborted))
        return Aborted;
    else if (sourceStates.contains(Cancelled))
        return Cancelled;
    else
        return Initial;
}
--------

Since the Task Group is also the top level structure of the Task List, the inferred state of the List as a whole is also provided by this algorithm.

=== Execution History

The history of execution events is represented in the class `EXECUTION_HISTORY`. This is a history of real world execution events that accumulate over the duration of workflow processing of the Task List. Two types of event are used:

* `TASK_EVENT_RECORD`: type representing a change to one consitutent Task. Thus, if the performer cancels a particular Task within the list, a `TASK_EVENT_RECORD` will be added to the history, including Task id, time, and reason; notifications can also be recorded on such events;
* `_LIST_EVENT_RECORD_`: type representing any kind of execution event not linked to a specific Task, for example 'list abandonment'.

The first type may also include forward references to EHR Entries that were committed as a result of a Task being performed. This facilitates logical indexing of planned and performed work items.

The Execution history will clearly grow and might become quite long for some Task List executions. How it may be persisted in various ways. The following possibilities are all compatible with both the model, and typical EHR requirements:

* In workflow application persistence:
** persist the full history, delete or archive once the Task List is fully completed;
* In the EHR:
** persist the full history in some or all cases, if useful in the EHR environment (e.g. for teaching);
** persist a partial / filtered version of the history, e.g. retain only _cancel_ and _abort_ events, on the basis that completed Tasks will show up as `ACTIONs` elsewhere in the EHR;
** don't persist any of the history - rely on the workflow application persistence for it during execution, and forget afterward.

This approach cleanly separates the definitional representation of a Task List, which should only change if changes to the plan are made, and the execution state, which is built during the work performance.

=== Class Descriptions

include::{uml_export_dir}/classes/task_lifecycle.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/execution_history.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/list_event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_notification_record.adoc[leveloffset=+1]

== Relationship with other openEHR Artefacts

The model enables a flexible relationship between a Task List and orders, i.e. openEHR `INSTRUCTIONs`. In simple cases, a Task List will just be the list of Tasks to fulfill one order, i.e. a single `INSTRUCTION`, such as a prescription for a course of antibiotics. The general case however is that the Task List corresponds to a clinical goal which implicates multiple orders, for example the CHOP chemotherapy mentioned above. 

It may also be the case that _not every Task is associated with an order_. While a typical case is that a Task corresponds to an openEHR `ACTION` that has not yet been recorded (and which normally has a driving `INSTRUCTION`), it may also correspond to an `ACTION` that has no `INSTRUCTION` or indeed an `OBSERVATION` or possibly an `EVALUATION` (perhaps some kind of check during a procedure). There is also no reason why a Task List cannot consist of Tasks that define administrative work and would be documented with openEHR `ADMIN_ENTRYs`.

We can infer from the above that the main driver of a Task List isn't in general an order, but a guideline or protocol which usually includes orders. In simple cases, no formal protocol is used, and the orders (i.e. `INSTRUCTIONs`) may be _de facto_ drivers, or the Task List may be created _ad hoc_, such an in-patient pain medication administration plan by nursing staff. At the other extreme, a Task List may be created with no corresponding orders (and therefore no `INSTRUCTIONs`) at all.

The following figure shows the correspondences between the various type of openEHR artefact for the general case of Task Lists. The arrows indicate causal relationships.

[.text-center]
.openEHR Planning Artefact Relationships
image::diagrams/planning_artefacts.svg[id=planning_artefact_relationships, align="center", width=50%]

In the above, items in yellow are driven solely by the guideline and have no corresponding order; planned items with a red cross have been cancelled and have no corresponding performed Action or Observation.

One of the side-effects of distinct state machines for `INSTRUCTIONs` and Task Lists is that not all careflow steps and states in the former need to be represented as Tasks in a Task List. For example, a significant number of careflow steps defined in `ACTION` archetypes are for non-Active states, i.e. Planning, Postponement, Suspension etc. These steps do not need to have Tasks defined for them, since by definition they are nearly all unplanned. 

As a consequence, most Tasks in a Task List correspond only to Active-state careflow steps of constituent order `INSTRUCTIONs`.

== Cost Tracking

[.tbd]
TBD: describe cost tracking.

=== Class Descriptions

include::{uml_export_dir}/classes/task_costing.adoc[leveloffset=+1]

== Transactional Micro-service

The information structures required to represent planned Tasks and references at runtime are likely to be non-trivial. For this reason, a Micro-service is defined, with a transactional interface that converts transactional calls to correct underlying information structures.

[.tbd]
TBC: 

=== Class Descriptions

include::{uml_export_dir}/classes/task_planning_ms.adoc[leveloffset=+1]

== Execution-time EHR Structures

The model described here provides significant power when used with openEHR Instructions, Actions and Observations to represent clinical work driven by guidelines and order sets. This section describes the relationship of information instances that correspond to the various phases of work described earlier, as follows:

* _ordering_: creation of `INSTRUCTIONs`;
* _task planning_: creation of `TASK_LIST(s)` representing a plan of individual tasks that achieve the order intention;
* _execution_: creation of `ACTION` and other Entry types that document the Tasks as they were performed.

The model supports logical linking between these items to support workflow traceability. The following figure illustrates both aspects, which are further described below.

[.text-center]
.Runtime planning structures
image::diagrams/planning_runtime_structures.svg[id=runtime_planning_structures, align="center", width=80%]

Various links can be recorded at execution time, as follows:

* *planned Task to Order reference*: the `TASK_EVENT_RECORD.entry_instances` attribute is used to record reverse reference(s) from a `TASK` to an `ACTIVITY` within an `INSTRUCTION` that records a corresponding order, if one exists (shown on the diagram as a logical link from `DEFINED_TASK` to `ACTIVITY` instances);
* *planned Task to performed Task reference*: the `TASK_EVENT_RECORD.entry_instances` attribute is used to record a forward reference to the Entry instance that was created when this Task was performed, i.e. some `ACTION`, `OBSERVATION` etc (shown on the diagram as a logical link from `DEFINED_TASK` to `ACTION` instances);
* *performed Task to planned Task reference*: the `ENTRY._workflow_id_` attribute may be used to record a reverse reference from an `ACTION`, `OBSERVATION` etc to a causing `TASK` instance.
