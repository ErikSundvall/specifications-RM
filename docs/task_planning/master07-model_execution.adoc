= Task Execution Model

== Overview

The following figure shows the execution related part of the `rm.task_planning` package. The consists of two parts: the runtime part, and the 'execution history' part. The former is a partial specification of classes that could be instantiated at Task Plan execution time to track Plan execution, and is provided as a guide to how execution tracking can be done. The latter classes describe the execution history after the fact, in the form of 'event records' that can optionally be stored in the EHR after Task Plan execution has completed.

[.text-center]
.rm.task_planning package - execution model
image::{uml_export_dir}/diagrams/RM-task_planning-execution.svg[id=rm_task_planning_execution, align="center"]

== Task Plan Execution Tracking

There are various aspects to Task Plan execution, some of which are complex, and not directly covered by this specification. The execution phases are as follows: 

* *instantiation*: create an instance of this Task Plan in the Task Plan application;
* *allocation*: allocate the Plan instance to an authenticated user, as principal performer;
* *execution*: the Task Plan application displays Tasks and advances the state of execution view interactions with the user;
** each interaction, also change of principal performer, abandonment, and any other events will cause generation of Execution history events, which may be persisted;
* *commit to EHR*: an updated state of the Task Plan may be committed to the EHR, containing final lifecycle states and execution history.

During a long-running Task Plan, the principal performer may change. This will usually be the case for Task Plans that run longer than a work shift.

=== Task Plan Instantiation

Initially, a Task Plan definition that has been created will have the lifecycle state value `planned` in each `TASK_ITEM` instance. When the definition is activated, it is instantiated within a Task execution application. This creates a copy of it, or part of it, along with instances of the `RT_XXX` classes ('RT' = runtime). 

At instantiation, an instance of `RT_TASK_PLAN` is created and the  `_start_time_` attributes set to the current time respectively. This object will normally be maintained for the lifetime of execution of the Task Plan. If there are execution times in the plan, they will be trivially convertable to absolute clock times. The `_lifecycle_state_` attribute of one or more `RT_TASK` instances may be set to `available` at this point, or at a later time if scheduled for specific times.

At the same time, an instance of `EXECUTION_HISTORY` is also created, proving a root points to accumulate Task Plan execution event records.

=== Allocation

Before an instantiated Task Plan can be executed, it must be allocated. This is done by user authenticating to the Task Plan application; this user will be set as the `_principal_performer_` in the `RT_TASK_PLAN` instance.

=== Task Execution

=== Task Lifecycle Model

During execution, each Task is represented by an instance of `RT_TASK` that refers back to its `TASK` definition instance. Each Task in the Plan has a lifecycle consisting of various states it may pass through in time. Changes in the lifecycle are recorded in `RT_TASK._lifecycle_state_`. The lifecycle is simple, since it only has to take account of the states a Task itself can pass through, with documentation of the Task execution occurring in the form of separate openEHR `ACTION` or other Entry objects. The states are as follows:

* _initial_: initial pseudo-state, not used in operation;
* _planned_: defined, but not available for execution;
* _available_: available for execution, due to previous Tasks having been performed, preconditions being met, wait conditions having been satisfied and if there is a time specification on the Task, the current time being at or later than the stated time;
* _cancelled_: cancelled prior to being performed;
* _completed_: performed to completion;
* _aborted_: execution was commenced but stopped before completion.

The corresponding state machine is shown below.

[.text-center]
.Task lifecycle state machine
image::{uml_export_dir}/diagrams/RM-TaskStateMachine.svg[id=task_state_machine, align="center", width=60%]

It may be that one or more Tasks do not evaluate to `available` at runtime when the principal performer wants to treat them as being available. This may happen if the performer wants to execute a Task earlier than scheduled, or decides that an unmet precondition or wait condition does not matter (for example, they may know that it is met, but the Task Plan application may not yet know). Accordingly, an override option 

Since a Task Plan is a hierarchical structure consisting of one or more Task Groups, a way of rolling up Task state is needed. The following algorithm is used to compute the effective lifecycle state of a `RT_TASK_GROUP` from the set of states of its members (which may include other `RT_TASK_GROUPs`).

[source, java]
--------
//
// Infer the state of a collection whose members have states in sourceStates.
// The order of if/else evaluation determines the correct result.
//
TaskState inferredState (Set<TaskState> sourceStates) {
    TaskState inferredStateValue;
    if (sourceStates.contains(Available))
        return Available;
    else if (sourceStates.contains(Planned))
        return Planned;
    else if (sourceStates.contains(Completed))
        return Completed;
    else if (sourceStates.contains(Aborted))
        return Aborted;
    else if (sourceStates.contains(Cancelled))
        return Cancelled;
    else
        return Initial;
}
--------

Since the runtime Task Group is also the top-level structure of the runtime Task Plan, the inferred state of the Plan as a whole is also provided by this algorithm applied to the top-level runtime Task Group.

Lifecycle state values recorded in `RT_TASK` objects may be copied into the `_lifecycle_state_` attributes of the corresponding definition Task objects if required, for example, in order to persist a final snapshot of the Task Plan into the EHR.

NOTE: This is the only execution time related attribute in the Task Plan definition. If it is necessary to record the final lifecycle states of Tasks in a completed Task Plan, the `TASK_PLAN` will need to be re-committed to the EHR as a new version in order to achieve this.

=== Notifications

Notifications can be specified to be generated at various lifecycle state changes.

[.tbd]
To be continued

=== Class Descriptions

include::{uml_export_dir}/classes/task_lifecycle.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/rt_task_plan.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/rt_wait_conditions.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/rt_plan_item.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/rt_task_item.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/rt_decision_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/rt_task_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/rt_task.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/rt_decision_path_group.adoc[leveloffset=+1]

== Task Plan Execution History

The history of execution events is represented in the runtime instance of `EXECUTION_HISTORY`. This is a history of real world execution events that accumulate over the duration of processing of the Task Plan. Two types of event are used:

* `TASK_EVENT_RECORD`: type representing a change to one consitutent Task. Thus, if the performer cancels a particular Task within the list, a `TASK_EVENT_RECORD` will be added to the history, including Task id, time, and reason; notifications can also be recorded on such events;
* `TASK_PLAN_EVENT_RECORD_`: type representing any kind of execution event not linked to a specific Task, for example 'plan abandonment', 'new principal performer'.

The first type may also include forward references to EHR Entries that were committed as a result of a Task being performed. This facilitates logical indexing of planned and performed work items.

The Execution history will clearly grow and might become quite long for some Task Plan executions. How it may be persisted in various ways. The following possibilities are all compatible with both the model, and typical EHR requirements:

* In the Task Plan application persistence:
** persist the full history, delete or archive once the Task Plan is fully completed;
* In the EHR:
** persist the full history in some or all cases, if useful in the EHR environment (e.g. for teaching);
** persist a partial / filtered version of the history, e.g. retain only _cancel_ and _abort_ events, on the basis that completed Tasks will show up as `ACTIONs` elsewhere in the EHR;
** don't persist any of the history - rely on the workflow application persistence for it during execution, and forget afterward.

This approach cleanly separates the definitional representation of a Task Plan, which should only change if changes to the plan are made, and the execution state, which is built during the work performance.

=== Class Descriptions

include::{uml_export_dir}/classes/task_plan_execution_history.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_plan_event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_notification_record.adoc[leveloffset=+1]

== Cost Tracking

[.tbd]
TBD: describe cost tracking.

=== Class Descriptions

include::{uml_export_dir}/classes/task_costing.adoc[leveloffset=+1]

== Transactional Micro-service

The information structures required to represent planned Tasks and references at runtime are likely to be non-trivial. For this reason, a Micro-service is defined, with a transactional interface that converts transactional calls to correct underlying information structures.

[.tbd]
TBC: 

=== Class Descriptions

include::{uml_export_dir}/classes/task_planning_ms.adoc[leveloffset=+1]

