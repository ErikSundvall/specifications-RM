= Task Execution Model

== Overview

The following figure shows the execution related parts of the `rm.task_planning` package. The consists of two parts: the _materialised_ representation, and the _execution history_ part. The former is a partial specification of classes that could be instantiated at Task Plan execution time to track Plan execution, and is provided as a guide to how execution tracking can be done. The latter classes describe the execution history after the fact, in the form of _event records_ that can optionally be stored in the EHR after Task Plan execution has completed.

[.text-center]
.rm.task_planning package - execution model
image::{uml_export_dir}/diagrams/RM-task_planning-execution.svg[id=rm_task_planning_execution, align="center"]

== Task Plan Execution Tracking

There are various aspects to Task Plan execution, some of which are complex, and not directly covered by this specification. The execution phases are as follows: 

* *materialisation*: create an instance of (parts of) this Task Plan in the Task Plan execution engine;
* *allocation*: allocate the Plan instance to an authenticated user, as principal performer;
* *execution*: the Task Plan application displays Tasks and advances the state of execution view interactions with the user;
** each interaction, also change of principal performer, abandonment, and any other events will cause generation of Execution history events, which may be persisted;
* *commit to EHR*: an updated state of the Task Plan may be committed to the EHR, containing final lifecycle states and execution history.

During a long-running Task Plan, the principal performer may change. This will usually be the case for Task Plans that run longer than a work shift.

=== Task Plan Materialisation

Initially, one or more Task Plan definitions of a Work Plan that has been defined will have the lifecycle state value `planned` in each `TASK_ITEM` instance. When the definition is activated, it is instantiated within a Plan execution engine. This creates a copy of it, or part of it, along with instances of the `M_XXX` classes ('RT' = runtime). This particular instance form is called the _materialised form_ in this specification.

At materialisation, an instance of `M_TASK_PLAN` is created and the  `_start_time_` attributes set to the current time respectively. This object will normally be maintained for the lifetime of execution of the Task Plan. If there are execution times in the plan, they will be trivially convertable to absolute clock times.

The materialised form of the detailed structure of the plan may be instantiated fully, or only partially, where convenient. For example, if most of the plan has been completed, and only some steps remain, it may make sense to instantiate only the `M_XX` instances corresponding to those steps. On the other hand, an applicaiton may want to display the details of the whole plan, even when only a small part remains to be executed.

The structure created will mirror the structure of the definition, to the extent of run-time structure creation, if it is partial. That is to say, `M_TASK_GROUP` instances will have `_members_` containing further `M_XX` instances, that mimic the `TASK_GROUP` structures within the Plan definition.

When the structure creation has been completed, the `_lifecycle_state_` attribute of one or more `M_TASK` instances may be set to `available`, or if picking up from a previous session, to other states (i.e. `completed` etc), as appropriate.

At materialisation time, an instance of `EXECUTION_HISTORY` is also created, proving a root point to accumulate Task Plan execution event records.

=== Allocation and re-allocation

Before a materialised Task Plan can be executed, the `_principal_performers_` of its `TASK_GROUPs` must be _allocated_ to real actors. This is done by user(s) authenticating to the Plan execution engine and signing up for specific roles and functions within the Plan. Not all performers are needed at any time, only those implicated in some defined part of the Plan to be executed, e.g. for the current day within a multi-day Plan.

At various moments during the execution of a Plan, a performer may leave and be replaced by another performer, e.g. due to worker shift changeover. This requires a de-allocation of the leaving performer from the Plan and a new allocation of a new actor.

=== Task Lifecycle Model

During execution, each Task is represented by an instance of `M_TASK` that refers back to its `TASK` definition instance. Each Task in the Plan has a lifecycle consisting of various states it may pass through in time. Changes in the lifecycle are recorded in `M_TASK._lifecycle_state_`. The lifecycle is simple, since it only has to take account of the states a Task itself can pass through, with documentation of the Task execution occurring in the form of separate openEHR `ACTION` or other Entry objects. The states are as follows:

* _initial_: initial pseudo-state, not used in operation;
* _planned_: defined, but not available for execution;
* _available_: available for execution, due to previous Tasks having been performed, preconditions being met, wait conditions having been satisfied and if there is a time specification on the Task, the current time being at or later than the stated time;
* _cancelled_: cancelled prior to being performed;
* _completed_: performed to completion;
* _aborted_: execution was commenced but stopped before completion.

The corresponding state machine is shown below.

[.text-center]
.Task lifecycle state machine
image::{uml_export_dir}/diagrams/RM-TaskStateMachine.svg[id=task_state_machine, align="center", width=60%]

It may be that one or more Tasks do not evaluate to `available` at runtime when the principal performer wants to treat them as being available. This may happen if the performer wants to execute a Task earlier than scheduled, or decides that an unmet precondition or wait condition does not matter (for example, they may know that it is met, but the Task Plan application may not yet know). Accordingly, an override option 

Since a Task Plan is a hierarchical structure consisting of one or more Task Groups, a way of rolling up Task state is needed. The following algorithm is used to compute the effective lifecycle state of a `M_TASK_GROUP` from the set of states of its members (which may include other `M_TASK_GROUPs`).

[source, java]
--------
//
// Infer the state of a collection whose members have states in sourceStates.
// The order of if/else evaluation determines the correct result.
//
TaskState inferredState (Set<TaskState> sourceStates) {
    TaskState inferredStateValue;
    if (sourceStates.contains(Available))
        return Available;
    else if (sourceStates.contains(Planned))
        return Planned;
    else if (sourceStates.contains(Completed))
        return Completed;
    else if (sourceStates.contains(Aborted))
        return Aborted;
    else if (sourceStates.contains(Cancelled))
        return Cancelled;
    else
        return Initial;
}
--------

Since the runtime Task Group is also the top-level structure of the runtime Task Plan, the inferred state of the Plan as a whole is also provided by this algorithm applied to the top-level runtime Task Group.

Lifecycle state values recorded in `M_TASK` objects may be copied into the `_lifecycle_state_` attributes of the corresponding definition Task objects if required, for example, in order to persist a final snapshot of the Task Plan into the EHR.

NOTE: This is the only execution time related attribute in the Task Plan definition. If it is necessary to record the final lifecycle states of Tasks in a completed Task Plan, the `TASK_PLAN` will need to be re-committed to the EHR as a new version in order to achieve this.

=== Notifications

Notifications can be specified to be generated at various lifecycle state changes.

[.tbd]
To be continued

=== Persistence

The run-time instance structure may need to be persisted to enable a partial execution of a long-running Task Plan to be recorded and picked up when later tasks become ready. In theory, this could be within the EHR, but it is recommended that either a specific EHR area be used for this, or that run-time state persistence be implemented outside the EHR proper.

[.tbd]
issue-runtime-persistence: if within the EHR, we could create a new 'pointer' on the EHR object that points to 'task runtime state' data or similar. Is this a useful thing to do?

=== Context Switching

[.tbd]
TBD: describe context switch for hand-off, external requests etc.

=== Class Descriptions

include::{uml_export_dir}/classes/m_task_plan.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/m_wait_conditions.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/m_plan_item.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/m_task_item.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/m_decision_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/m_task_group.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/m_task.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/m_decision_path_group.adoc[leveloffset=+1]

== Task Plan Execution History

The history of execution events is represented in the runtime instance of `EXECUTION_HISTORY`. This is a history of real world execution events that accumulates over the duration of processing of the Task Plan. Two types of event are used:

* `TASK_EVENT_RECORD`: type representing a change to one consitutent Task. Thus, if the performer cancels a particular Task within the list, a `TASK_EVENT_RECORD` will be added to the history, including Task id, time, and reason; notifications can also be recorded on such events;
* `TASK_PLAN_EVENT_RECORD_`: type representing any kind of execution event not linked to a specific Task, for example 'plan abandonment', 'new principal performer'.

The first type may also include forward references to EHR Entries that were committed as a result of a Task being performed. This facilitates logical indexing of planned and performed work items.

The Execution history will clearly grow and might become quite long for some Task Plan executions. How it may be persisted in various ways. The following possibilities are all compatible with both the model, and typical EHR requirements:

* In the Task Plan application persistence:
** persist the full history, delete or archive once the Task Plan is fully completed;
* In the EHR:
** persist the full history in some or all cases, if useful in the EHR environment (e.g. for teaching);
** persist a partial / filtered version of the history, e.g. retain only _cancel_ and _abort_ events, on the basis that completed Tasks will show up as `ACTIONs` elsewhere in the EHR;
** don't persist any of the history - rely on the workflow application persistence for it during execution, and forget afterward.

This approach cleanly separates the definitional representation of a Task Plan, which should only change if changes to the plan are made, and the execution state, which is built during the work performance.

=== Class Descriptions

include::{uml_export_dir}/classes/task_plan_execution_history.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_plan_event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_event_record.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_notification_record.adoc[leveloffset=+1]

== Cost Tracking

[.tbd]
TBD: describe cost tracking.

=== Class Descriptions

include::{uml_export_dir}/classes/task_costing.adoc[leveloffset=+1]

== Transactional Micro-service

The information structures required to represent planned Tasks and references at runtime are likely to be non-trivial. For this reason, a Micro-service is defined, with a transactional interface that converts transactional calls to correct underlying information structures.

[.tbd]
TBC: 

=== Class Descriptions

include::{uml_export_dir}/classes/task_planning_ms.adoc[leveloffset=+1]

