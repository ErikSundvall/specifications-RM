= Design Principles

The following sections describe some of the key ideas in the design of the Task Planning model defined in this specification.

== Conceptual Basics

=== Work Plan

The top-level formal concept defined here is the _Work Plan_, which consists of a set of one or more _Task Plans_. The Work Plan is a definition of work to be performed by one or more workers in order to achieve a defined goal with respect to a subject of care. Goals are often defined by published guidelines or care pathways, and the overall structure of work defined within a Work Plan and its constituent Task Plans may well be structured according to such publications.

Within a Work Plan, each included Task Plan is a definition of work to be performed in a single work _context_, typically by a single worker. Multiple Plans occur for two reasons:

* distinct performers working in different contexts, across which managed _handoffs_ are required;
* _sub-plans_ subordinate to a parent Plan, to be performed by the same worker. 

Sub-plans occur to allow re-use of Plans for smaller pieces of work and also to provide a means of controlling the detail level of work differently for performers of different experience levels.

The entirety of the Work Plan definition is assumed to be executable within a single computational context, in which methods of notification and worker communication are available, enabling the state of progress of the work defined in the Plan to be fully represented computationally. A Work Plan will often be limited to a single enterprise, but this need not be the case, as long as all of its Task Plans communicate within the same Plan execution context. More typically, some jobs required by a Work Plan are performed in another organisational context entirely, and from the point of view of the original Work Plan, the second organsation is seen as a 'black box' to which a request can be made and a result might be returned. A common example is a hospital clinical workflow that at some point requires a laboratory result, which is processed by an external organisation.

=== Task Plan

The actual definition of work to be done, i.e. Tasks, occurs within each Task Plan. The most basic structuring notion required is that of a sequential list of Tasks, enabling the representation of the set of steps in a typical linear workflow such as making tea or cleaning a wound.

However, in the real world, almost every job can be sub-divided into smaller pieces of work in a fractal nature. This simple fact requires that the general structure of Tasks is actually a hierarchy, within which sequential lists occur commonly (and will be the top-level structure in simple cases). The formal construct provided for this is the Task Group, which may contain Tasks and more Task Groups.

The Task Group provides a convenient place to state _repetitions_ that may be required or allowed, as occurs with many routine clinical and related jobs.

With hierarchy and sequential execution semantics, a great many types of work can be represented. However, some sets of Tasks can be performed without regard to order - i.e. in parallel. The model defined here therefore includes an execution type indicator at the Task Group level, so that manner of performing the work items within a Group - with or without regard to order - can be indicated. In purely sequential Task Plans, there is only one _execution path_. Parallel execution enables the possibility of multiple execution paths during a Plan execution.

The availability of parallelism in a Task Plan, particularly where the parallel elements are whole Task Groups, also creates the possibility of _choice_. Rather than every parallel path being mandatory or arbitrarily optional, a set of parallel paths may be chosen according to a _decision node_ within the Plan, where a variable is evaluated and various value sub-ranges correspond to multiple paths. Such groups are represented by a Decision Group within the model, and each output path by a _Decision Path Group_.

The leaf level constituents of a Task Plan are Tasks of various kinds, including inline-defined Tasks; requests to other contexts within the same Work Plan; requests to external contexts and requests to IT systems and services.

The Task concept defined in this specification is relatively straightforward in the abstract: it corresponds to a separately performable _item of work_ for a _performer_ to execute. A Task within a Plan has a lifecycle whose states indicate whether it is planned, available, complete etc.

In business terms, a Task typically corresponds to:

* an explicit level of clinical responsibility, e.g. nurse administration of a drug, single observation of patient vital sign etc;
* an explicit level of re-imbursement / billing;
* granularity of check-list and protocol single items, designed to be signed off as performed;
* a particular planned time of execution.

We can summarise the above-described structure in reverse:

* *Task*: a separately performable unit of planned work at any level of granularity; may be defined inline or 
* *Task Group*: a group of Tasks and/or more Task Groups within a Task Plan that are to be executed on the same basis, e.g. sequential, parallel.
* *Decision Group* and *Decision Path Group*: two special kinds of Group that enable decision nodes to be represented in a Plan.
* *Task Plan*: a logical set of Tasks for a single performer context to achieve a defined result within a larger plan.
* *Work Plan*: top-level structure containing related Task Plans needed to implement an intended outcome for a subject of care.

=== Work Context

A fundamental concept in this specification is that of _work context_, which is the factor that distinguishes one Task Plan from another, i.e. one Plan corresponds to Tasks to be performed in a single work context. Work context is defined as a single, _contiguous cognitive flow_ in the real world (i.e. not in the computational representation, which must always be considered an approximation updated in snapshot fashion) in which work can be performed _seamlessly_ by one or more performers on a single subject. Concretely, this means that the flow of cognitive activity is unbroken during the work. This may extend over time and even distinct physical spaces, such as in the case of tele-consultations. Normally a single cognitive flow corresponds to a single actor, usually a person, but this is not always the case. More than one person may be involved in performing work on the same subject, but essentially working as one, and relying on real-time verbal or other communication to achieve the effect of a _single mind_.

Continuous knowledge of the work, and continuous real-time communication with oneself ('train of thought') or directly among multiple performers is what characterises a given context. A different context is one with different cognitive actors, and with which communications is performed by notifications at certain time checkpoints, typically just the beginning and end.

Since parallelism is possible within a single Plan, a performer may be working on more than one thing at once, within the same context. In other words, a work context (and a Task Plan in execution) may contain multiple execution paths at a point in time.

=== Context Switching and Forking

If work has to be stopped within one context and passed to a different work context, a _context switch_ is required, and the first worker or team will wait for a response. If the context switch is within the same Work Plan, is termed a _handoff_, which entails switching Task Plans. A context change is also required to request work from an external environment. A second kind of change of control is a _context fork_, whereby the current performer signals to another context to start doing some work, but continues doing his own work. 

A context switch is commonly known as 'block and wait' or 'synchronous processing', while the context fork is known as 'asynchronous' or 'parallel' processing.

Work context is clearly maintained during a 'working session' during which the work is done by one or more performers. But if the work extends over hours or days, as in the case of chemotherapy, worker shifts will end and the work will be taken up by new workers, or perhaps the same workers on the next day. The Task Planning model does not consider this kind of _handover_ to be a context switch, since it is assumed that the Task Planning runtime system maintains all relevant context information, available for use by new workers. All that is required to maintain the context is for de-allocation and re-allocation of the work to performers.

=== Principal Performer

All Tasks in a Plan are defined to have a _principle performer_, that is to say, a single logical actor. This is often a single person (or a device or possibly a software service), but might equally be a group of personnel, e.g. ward nurses, who execute the steps of a Task Plan during and across shift boundaries (wound dressing, turning patients, IV maintenance etc). In these cases there is an understanding by separate individuals that they constitute a common workforce with respect to the subject of care, for any given planned piece of work.

The principal performer can be specified in terms of professional roles, and optionally a specific agent. This might in some cases be the patient.

The principle performer is defined to be attached to a Task Group in the model. This enables a Task Plan by default to have a single principle performer attached to the top-level Task Group, but to be overridden at lower level Groups.

In addition to the principal performer, other participations can be specified for any contained Task in a Plan. However it is assumed that the principal performer is _responsible_ for all actions, and is also the notifier of action completions and cancellations, as well as the target of notifications to do with linked Task Plans.

The consequences of this design principle are twofold:

* where a team of executing actors is required to perform a logical procedure, _a Plan may have more than one principal performer in different Group sections, or alternatively, each distinct actor has his or her own Task Plan_;
* for a team to operate together, coordination between the Task Plans and relevant actors is achieved by context switching.

A couple of subtleties are created by the design choice to allow more than one principal performer for a Plan. Firstly, where a change of principle performer is indicated in a Task Plan, a change of concrete actor is normally intended at execution time, but this need not always be so. A Plan designed for mainly nursing tasks with one or two tasks for a consultant or other specialist could be fully performed by a single professional having the specific capacities required by the Plan. 

Secondly, a change in principal performer _within_ a Task Plan is not treated as a formal context switch, i.e. one formally represented in the Plan. Instead, the switch is assumed to be undertaken by means of allocation of the relevant actors, in a seamless manner within the same cognitive context (typically managed by verbal communication).

=== Allocation

Since a Task in a Task Plan being executed at runtime represents the Plan execution system's knowledge of some work being performed in the real world, a way to connect the Task in the system (e.g. as shown on a UI application, or via notifications such as instant messaging) to the real-world actor performing it is needed. Following YAWL, the architecture described here treats _allocation_ of work to a performer as a formal action during Plan execution. As per YAWL, more sophisicated implementations of Task Planning may offer numerous allocation strategies, such as first-available, quickest-to-complete, least-frequently-used and so on.

== Phases of Definition and Representation

Task Plans are defined, refined and used in various phases in time. A number of related technical representations are used, each appropriate to its phase.

[cols="2,3,6", options="header"]
|===
|Phase                   |Representation             |Purpose

|Design time             |*Definition template* +
                          (archetypes of definition +
                          classes)                   |A Task Plan template is a 'prototypical' definition of a Task Plan that may be used in multiple situations;                                     it is represented in the form of openEHR templated archetype(s) based on the Task Planning definition
                                                      model of this specification.
|Clinical time - +
 planning               |*Concrete definition* +
                         (instances of definition +
                          classes)                   |When a Task Plan prototype is _used_, it is created as instances of the Task Planning definition
                                                      model (i.e. in the technical class/instance sense), and the result is understood as a _concrete_ definition
                                                      of the Task Plan to be used in a specific situation for a specific subject (i.e. patient); any modifications allowed by the archetypes may be made to achieve the specific Task Plan needed.
|Clinical time - +
 plan execution         |*Materialised form* +
                        (instances of +
                         materialised classes, +
                         persisted over sessions)    |At Plan execution time, a Task Plan definition will be 'materialised', i.e. instantiated into a form that can                                    be used for execution and tracking of the Plan. In this form, repeatable sections of the definition are                                          'unfolded' into literal sections, for as many repetitions as required by the relevant performer(s). 
                         
                                                      Accordingly, parts of the materialised expression of a Plan may have an N:1 relationship with the original definition form. The materialised form has its own class model, containing additional data items to enable run-time tracking of the Plan as it is performed. During execution time, various kinds of deletions and modifications to the materialised representation, corresponding to changes in plan that respond to unexpected events.
|Clinical time - +
 task execution         |*Runtime instantiation* +
                        (instances of +
                         materialised classes, +
                         during session)            |Since a Plan execution may run over many hours, days or longer, the materialised expression will in general                                     correspond to something larger than the literal in-memory instantiation of (parts of) the Plan required during                                   any given user-application the session during which some or all of the Task Plan might be performed. The part                                   of the plan currently being displayed, performed, tracked etc, is known here as the 'run-time instantiation',                                   and consists of a subset of the total materialised form instances.
 
|===

In this scheme, archetypes and templates conveniently provide a prototype level of definition that supports standard models of similar but not identical kinds of Task Plan. For example, a single set of archetypes and templates could be used to represent Task Plans for hospital drug administration which can then be further customised for particular patients at the concrete definition level.

=== Separation of Definition and Execution

According to the above, the concrete definition of a Task Plan is constructed in the 'planning phase' of clinical time, to define work _to be done_ in the near future, by the planner and/or others. As the work is performed, the results are documented with openEHR Entries, such as Actions and Observations. During the execution of the plan there is usually a need to track the progress of the work in terms of Task completions, cancellations, failures, abandonment and so on.

As per the above table, the model defined in this specification separates the definition of Task Plans from their executions. This is achieved via `definition` and `materialised` parts of the model, corresponding to the concrete definition and materialised phases described above. Instances of the former are used to represent the definition of a plan, and would accordingly be used by a tools designed for that purpose. Similarly, run-time execution tools would be built using the `materialised` part of the model, as well as the `definition` part, since the latter is referred to by the former.

It is the materialised expression of a Plan that is used to record all Plan-related actions by Task performers. This state may be persisted for plans whose execution takes place over more than a user-application session.

The history of actions on the Plan can be understood as a set of _transactions_ over time, and the model provides a third `history` part that can be used to efficiently represent this history, allowing it to be permanently recorded.

=== Model of Change

TODO: document how / when changes can be made, including during execution.

== Execution Semantics

A Work Plan definition can be executed by being materialised. The model recognises three states in the execution phase, as follows.

* `materialised` state: after creation of the materialised Plan, the Plan may be modified by its user(s), and connections must be established between the Plan execution context and various channels via which performer allocation and communication can be achieved.
* `activated` state: the materialised Plan is _activated_ when the users want to proceed. This establishes the zero point of the execution clock, and will cause performer allocations and generate various kinds of notifications as time moves forward. During the work, Tasks become _available_ (see below) as earlier Tasks are completed or cancelled. When a Task is available to be done, the performer has various options, including doing the work, cancelling the Task as not needed, completing the Task, aborting it, and abandoning the entire Plan.
* `terminated` state: A Plan terminates when a path taken through the materialised Task graph terminates, either due to finishing, or due to abandonment at an intermediate Task. The Plan as a whole returns a termination status of success or fail, which may be used to control behaviour if it is part of a chain in which a context switch follows termination.

=== Task Lifecycle

Every Task in a Plan has a lifecycle described by a state machine. The states represent the state of a real world item of work, _as known by the Plan execution system_; setting them is entirely reliant on the system receiving input from performers. The successful execution path is through the states `planned` => `available` => `completed`, with other terminal states `cancelled` and `aborted` available for cases where a Task is cancelled and aborted respectively. Here, 'cancelled' means 'not needed', i.e. the principal performer determined Task could be cancelled before or during execution, without compromising the Plan. Conversely, the `aborted` state indicates that the performer cannot do or complete the Task, or the rest of the Plan. Thus, `aborted` for a Task means abandonment of the current Plan.

From the viewpoint of Plan execution, the final state of a Task execution determines whether the Plan remaints in the `active` state, or whether it enters the `terminated` state. If the Task terminates with `completed` or `cancelled` state, it is considered to have _succeeded_, and the Plan remains `active`. If the Task is `aborted`, it is considered as _failed_, and the Plan terminates with a failure status.

=== Task Availability

A Task becomes _available_ to perform when three kinds of condition are met: 

* Plan control flow;
* real world time, if execution time is specified in the Plan, and;
* subject pre-conditions.

Control flow reaches a Task in a Plan when either preceding Tasks have been performed (local control flow) or a previously dispatched external Task completes, whose restart location in the current Plan is the current Task.

Real-world execution time can be set for a Task, which means that even if it is available in terms of control flow, execution must wait until a specified time is reached. This may be simple clock time, a conventional time of day such as 'after lunch', or an event-relative time, such as 'at least 1 hour after last meal'.

If the control flow and time conditions are met, a Task will still not be available until any subject-related pre-conditions are met. These are conditions that may be specified to ensure the Task is only performed if it is clinically appropriate and safe to do so, such as 'systolic blood pressure < 160 mmHg'.

Since the Task Plan cannot presume to have perfect knowledge of the real world situation, the performer is always allowed to override the time and subject pre-conditions, due to better knowledge. In such cases, the control flow requirement still holds - since this can already be 'overridden' by the performing cancelling preceding Tasks where appropruate.

When a Task does become available for execution, nothing will happen until a performer is allocated to do it. When an available worker is allocated, further life-cycle states can be reached, i.e. 'completed', 'aborted' etc.

The following diagram illustrates these concepts.

[.text-center]
.Task Semantics
image::diagrams/task_semantics.svg[id=task_semantics, align="center", width=90%]

== Relationship of Task Plans with existing openEHR Entry Types

Within the phases of clinical planning and execution time described above, the Task Plan is not the only information artefact that may be created. The existing openEHR model `ENTRY` types provide the standard way to represent orders, via `INSTRUCTION`, and order-related performed activities, via `ACTION`. In addition, the usual `OBSERVATION`, `EVALUATION` and `ADMIN_ENTRY` types are used to record observations, diagnoses, and administrative events as they occur in clinical time. In abstract terms, Instructions may be understood as formal statements of 'what is to be done', and the other types, as records of 'what was done'. However, Instructions are most suited to concise representations of orderable actions, particularly medication administration, but not for general purpose detailed plans of events. The addition of Task Plans provides a way to specify such plans more flexibly, and in a step-by-step manner.

Both Instructions and Plans may be fully or partially defined by care pathways and/or guidelines, equally, they may be ad hoc developed in the 'old school medicine' sense. The following figure illustrates the relationships among care pathways, the existing openEHR Entry types and Task Plans. 

[.text-center]
.openEHR Planning Artefact Relationships
image::diagrams/planning_artefacts.svg[id=planning_artefact_relationships, align="center", width=60%]

In simple cases, a Task Plan may just be the list of Tasks to fulfill one order, i.e. a single `INSTRUCTION` prescribing a course of antibiotics. The general case however is that the Task Plan corresponds to a clinical goal which implicates multiple orders, such as the CHOP chemotherapy mentioned above. 

Consequently, _not every Task in a Task Plan is associated with an order_, illustrated by the yellow Task objects in the above figure. While a typical case is that a Task corresponds to an openEHR `ACTION` that has not yet been recorded (and which normally has a driving `INSTRUCTION`), it may also correspond to an `ACTION` that has no `INSTRUCTION` or indeed an `OBSERVATION` or possibly an `EVALUATION` (perhaps some kind of check during a procedure). Indeed, there is also no reason why a Task Plan cannot consist of Tasks that define administrative work and would be documented with openEHR `ADMIN_ENTRYs`.

We can infer from the above that the main driver of a Task Plan isn't in general an order, but a care plan or guideline that usually includes orders, or else plain old ad hoc planning.

A high-level view of how clinical work generates openEHR information can be visualised conceptually with a modified version of the {openehr_rm_ehr}#_information_ontology[Clinical Investigator process diagram] as follows:

[.text-center]
.Clinical Investigator Process with Planning
image::diagrams/clinical_process_planning.svg[id=clinical_process_planning, align="center", width=70%]

According to this scheme, `TASK_PLAN` and `TASK` are new types of information that can be committed to the EHR.

== Order Semantics versus Plan Semantics

Despite the above explanation, the difference between Instructions (as defined in openEHR) and Task Plans may not be completely clear. However, there is a key difference, which is the semantic level at which the two are expressed. A typical order, represented in an openEHR `INSTRUCTION` has an _algorithmic_ form, such as  "Amoxicillin 3 times a day, orally, for 7 days". Although healthcare professionals do not typically think about it, this expression is in fact a small program that is mentally _interpreted_ to produce resultant actions such as giving one tablet at 9:15 am, one at lunch and so on.

We can think of a Task Plan for ordered actions as the interpreted form of the original order statement(s), that is to say, a completely 'unfolded' list of single Tasks in time such as 'give 1 Amoxycillin oral tab at lunch'. This is a form suitable for displaying on work lists, checking off and ensuring no mistakes are made. When a Task is performed, it will still give rise to the appropriate openEHR Entry recording the details, such as 'gave 1 Amoxycillin tab at 13:37'.
