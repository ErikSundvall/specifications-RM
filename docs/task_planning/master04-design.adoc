= Design Principles

The following sections describe some of the key ideas in the design of the Task Planning model defined in this specification.

== Conceptual Basics

=== Key Entities: Work Plan and Task Plan

This specification defines two high-level kinds of entity: _Work Plan_ and _Task Plan_. A Task Plan (or 'Plan', for short) is a set of Tasks designed to achieve a particular outcome for a single subject of care, generally a single patient. It may have one or more performers, depending on whether a team is needed. It may also be composed of sub-plans, represented as other Task Plans. 

Since the work that multiple performers may be definable in a standalone sense (e.g. scans, tests, routine procedures such as IV catheterisation), but also used together in a guideline or pathway-based larger plan, such as stroke management, it is assumed that in general, more than one Task Plan may be collected together to achieve an overall plan intention. This construct is known here as a Work Plan. A Work Plan groups together Task Plans that refer to each other, either as sub-plans (re-use) or via handoffs (team work). It includes descriptive meta-data, and can be used by the Plan execution engine to determine the overall state of progress on the Plan.

=== Compositional Structure

In the real world, almost every Task can be sub-divided into a smaller set of Tasks. In addition, some sets of Tasks can be performed without regard to order - i.e. in parallel - while others must be ordered. This specification accordingly supports this hierarchical structure via three structural artefacts, namely Task Plan, Task Group and Task. These follow naturally from the requirements above, but we need to articulate the semantics of these concepts, as follows:

* *Task*: a separately performable unit of planned work.
* *Task Group*: a group of Tasks and/or more Task Groups within a Task Plan that are to be executed on some basis, e.g. sequential, parallel.
* *Task Plan*: a logical Task / Task Group structure, whose execution is intended to achieve completion of a coarse-grained task or goal with respect to a particular subject of care. Task Plans are a unit of reuse.
* *Work Plan*: top-level structure containing related Task Plans needed to implement the intended specific outcome for a subject of care.

The Task concept defined in this specification is relatively straightforward in the abstract: it corresponds to a separately performable _item of work_ for a _performer_ to execute, and may be either locally defined within a Plan, or else be a reference to work to be done elsewhere, either within the current Plan or in an external system or organisation. A Task within a Plan has a lifecycle whose states indicate whether it is planned, available, complete etc.

In business terms, a Task typically corresponds to:

* an explicit level of clinical responsibility, e.g. nurse administration of a drug, single observation of patient vital sign etc;
* an explicit level of re-imbursement / billing;
* granularity of check-list and protocol single items, designed to be signed off as performed;
* a particular planned time of execution.

=== Performers and Allocation

Since a Task in a Task Plan being executed at runtime represents the Plan execution system's knowledge of some work being performed in the real world, a way to connect the Task in the system (e.g. as shown on a UI application, or via notifications such as instant messaging) to the real-world actor performing it is needed. Following YAWL, the architecture described here treats _allocation_ as a formal step in the execution phase. As per YAWL, more sophisicated implementations of Task Planning may offer numerous allocation strategies, such as first-available, quickest-to-complete, least-frequently-used and so on.

=== Principal Performer

All Tasks in a Plan are defined to have a _principle performer_, that is to say, a single logical actor. This is often a single person (or a device or possibly a software service), but might equally be a group of personnel, e.g. ward nurses, who execute the steps of a Task Plan during and across shift boundaries (wound dressing, turning patients, IV maintenance etc). In these cases there is an understanding by separate individuals that they constitute a common workforce with respect to the subject of care, for any given planned piece of work.

The principal performer can be specified in terms of professional roles, and optionally a specific agent. This might in some cases be the patient.

The principle performer is for practical reasons defined to be attached to a Task Group in the model. This enables a Task Plan by default to have a single principle performer attached to the top-level Task Group, but to be overridden at lower level Groups.

In addition to the principal performer, other participations can be specified for any contained Task in a Plan. However it is assumed that the principal performer is _responsible_ for all actions, and is also the notifier of action completions and cancellations, as well as the target of notifications to do with linked Task Plans.

The consequences of this design principle are twofold:

* where a team of executing actors is required to perform a logical procedure, _a Plan may have more than one principal performer in different Group sections, or alternatively, each distinct actor has his or her own Task Plan_;
* for a team to operate together, coordination is required between the Task Plans and relevant actors. This is described in more detail below.

A couple of subtleties are created by the design choice to allow more than one principal performer for a Plan. Firstly, where a change of principle performer is indicated in a Task Plan, a change of concrete actor is normally intended at execution time, but this need not always be so. A Plan designed for mainly nursing tasks with one or two tasks for a consultant or other specialist could be fully performed by a single professional having the specific capacities required by the Plan. 

Secondly, a change in principal performer is not treated as a formal context switch, i.e. one formally represented in the Plan. Instead, the switch is assumed to be undertaken by means of allocation of the relevant actors, with no concept of blocking or continuing or other context change mechanism as described below.

=== Work Flow and Context Switching and Forking

The definition of a set of Tasks within a Plan unavoidably implies a 'work flow' notion, i.e. a _thread of control_ embodied in the current performer performing work. Since the idea of parallel processing is supported by the model specified here, there may be more than one extant Task or series of Tasks which the same performer works on. Each thread is denoted a _task thread_ within this specification.

Additionally, the combination of a specific Plan, a principal performer and a task thread is called a _context_, in a similar sense to the computer science meaning for operating systems and executing programs. It is assumed that switching between parallel task threads in the same plan is managed internally by the performing actor; accordingly this kind of context switch is not formally represented in this specification.

Changes of control flow between different actors and / or Plans are however represented in the model, to enable the details of context changes to be defined by a Plan author, and to enable an execution engine to manage control flow properly.

Two types of context change are supported in the model: _context switching_ and _context forking_, both of which are standard concepts in computer science. The first corresponds to the situation where the current peformer passes control to another actor and waits for his work to be done, while the second corresponds to a splitting of control flow, where an actor causes a request to another actor to start doing work, and then proceeds with his own original line of Tasks. A context switch is commonly known as 'block and wait' or 'synchronous processing', while the context fork is known as 'asynchronous' or 'parallel' processing.

== Phases of Definition and Representation

Task Plans are defined, refined and used in various phases in time. A number of related technical representations are used, each appropriate to its phase.

[cols="2,3,6", options="header"]
|===
|Phase                   |Representation             |Purpose

|Design time             |*Definition template* +
                          (archetypes of definition +
                          classes)                   |A Task Plan template is a 'prototypical' definition of a Task Plan that may be used in multiple situations;                                     it is represented in the form of openEHR templated archetype(s) based on the Task Planning definition
                                                      model of this specification.
|Clinical time - +
 planning               |*Concrete definition* +
                         (instances of definition +
                          classes)                   |When a Task Plan prototype is _used_, it is created as instances of the Task Planning definition
                                                      model (i.e. in the technical class/instance sense), and the result is understood as a _concrete_ definition
                                                      of the Task Plan to be used in a specific situation for a specific subject (i.e. patient); any modifications allowed by the archetypes may be made to achieve the specific Task Plan needed.
|Clinical time - +
 plan execution         |*Materialised form* +
                        (instances of +
                         materialised classes, +
                         persisted over sessions)    |At Plan execution time, a Task Plan definition will be 'materialised', i.e. instantiated into a form that can                                    be used for execution and tracking of the Plan. In this form, repeatable sections of the definition are                                          'unfolded' into literal sections, for as many repetitions as required by the relevant performer(s). 
                         
                                                      Accordingly, parts of the materialised expression of a Plan may have an N:1 relationship with the original definition form. The materialised form has its own class model, containing additional data items to enable run-time tracking of the Plan as it is performed. During execution time, various kinds of deletions and modifications to the materialised representation, corresponding to changes in plan that respond to unexpected events.
|Clinical time - +
 task execution         |*Runtime instantiation* +
                        (instances of +
                         materialised classes, +
                         during session)            |Since a Plan execution may run over many hours, days or longer, the materialised expression will in general                                     correspond to something larger than the literal in-memory instantiation of (parts of) the Plan required during                                   any given user-application the session during which some or all of the Task Plan might be performed. The part                                   of the plan currently being displayed, performed, tracked etc, is known here as the 'run-time instantiation',                                   and consists of a subset of the total materialised form instances.
 
|===

In this scheme, archetypes and templates conveniently provide a prototype level of definition that supports standard models of similar but not identical kinds of Task Plan. For example, a single set of archetypes and templates could be used to represent Task Plans for hospital drug administration which can then be further customised for particular patients at the concrete definition level.

=== Separation of Definition and Execution

According to the above, the concrete definition of a Task Plan is constructed in the 'planning phase' of clinical time, to define work _to be done_ in the near future, by the planner and/or others. As the work is performed, the results are documented with openEHR Entries, such as Actions and Observations. During the execution of the plan there is usually a need to track the progress of the work in terms of Task completions, cancellations, failures, abandonment and so on.

As per the above table, the model defined in this specification separates the definition of Task Plans from their executions. This is achieved via `definition` and `materialised` parts of the model, corresponding to the concrete definition and materialised phases described above. Instances of the former are used to represent the definition of a plan, and would accordingly be used by a tools designed for that purpose. Similarly, run-time execution tools would be built using the `materialised` part of the model, as well as the `definition` part, since the latter is referred to by the former.

It is the materialised expression of a Plan that is used to record all Plan-related actions by Task performers. This state may be persisted for plans whose execution takes place over more than a user-application session.

The history of actions on the Plan can be understood as a set of _transactions_ over time, and the model provides a third `history` part that can be used to efficiently represent this history, allowing it to be permanently recorded.

=== Model of Change

TODO: document how / when changes can be made, including during execution.

== Execution Semantics

A number of basic concepts apply to the execution phase of a materialised Task Plan. The general model is as follows.

* At any time after instantiation of the materialised Plan from its definition form, various changes can be made to the materialised structure, as long as they do not violate the constraints on the definition.
* Advance allocations of Tasks to concrete participants may be made in this phase.
* Connection to a notification push-channel must be made for every principal participant and external system mentioned in the Plan definition; these channels do not have to be all different (i.e. multiple parties may be communicated with via a single channel that talks to say a ward screen).
* The materialised Plan is _activated_ at some point in time after creation. This establishes the zero point of the execution clock, and will cause various kinds of notifications to occur as time moves forward.
* The execution system then creates notifications through the various channels to indicate Tasks to be executed for each type of performer. Where performers are already allocated, they may commence work and indicate back to the system the state of each Task as it proceeds through its lifecycle (below). For Tasks that are not yet allocated, a notification soliciting an acceptance is postedl when this is responded to by a user, work begins.
* During the work, Tasks become _available_ (see below) as earlier Tasks are completed or cancelled. When a Task is available to be done, the performer has various options, including doing the work, cancelling the Task as not needed, completing the Task, aborting it, and abandoning the entire Plan.
* Over time, the Plan remains in the active state until abandoned or completed.

[.tbd]
TBC: more

=== Task Lifecycle

Every Task in a Plan has a lifecycle described by a state machine. The states represent the state of a real world item of work, _as known by the Plan execution system_; setting them is entirely reliant on the system receiving input from performers. The successful execution path is through the states `planned` => `available` => `completed`, with other terminal states `cancelled` and `aborted` available for cases where a Task is cancelled (not needed) and aborted (unable to complete) respectively.

=== Task Availability

A Task becomes _available_ to perform when three kinds of condition are met: Plan control flow, real world time, and subject pre-conditions. Control flow reaches a Task in a Plan when either preceding Tasks have been performed (local control flow) or a previously dispatched external Task completes, whose restart location in the current Plan is the Task in question. 

Real-world execution time can be set for a Task, which means that even if it is available in terms of control flow, execution must wait until a specified time is reached. This may be simple clock time, a conventional time of day such as 'after lunch', or an event-relative time, such as 'at least 1 hour after last meal'.

If the control flow and time conditions are met, a Task will still not be available until any subject-related pre-conditions are met. These are conditions that may be specified to ensure the Task is only performed if it is clinically appropriate and safe to do so, such as 'systolic blood pressure < 160 mmHg'.

Since the Task Plan cannot presume to have perfect knowledge of the real world situation, the performer is always allowed to override the time and subject pre-conditions, due to better knowledge. In such cases, the control flow requirement still holds - since this can already be 'overridden' by the performing cancelling preceding Tasks where appropruate.

When a Task does become available for execution, nothing will happen until a performer is allocated to do it. When an available worker is allocated, further life-cycle states can be reached, i.e. 'completed', 'aborted' etc.

The following diagram illustrates these concepts.

[.text-center]
.Task Semantics
image::diagrams/task_semantics.svg[id=task_semantics, align="center", width=90%]

== Relationship of Task Plans with existing openEHR Entry Types

Within the phases of clinical planning and execution time described above, the Task Plan is not the only information artefact that may be created. The existing openEHR model `ENTRY` types provide the standard way to represent orders, via `INSTRUCTION`, and order-related performed activities, via `ACTION`. In addition, the usual `OBSERVATION`, `EVALUATION` and `ADMIN_ENTRY` types are used to record observations, diagnoses, and administrative events as they occur in clinical time. In abstract terms, Instructions may be understood as formal statements of 'what is to be done', and the other types, as records of 'what was done'. However, Instructions are most suited to concise representations of orderable actions, particularly medication administration, but not for general purpose detailed plans of events. The addition of Task Plans provides a way to specify such plans more flexibly, and in a step-by-step manner.

Both Instructions and Plans may be fully or partially defined by care pathways and/or guidelines, equally, they may be ad hoc developed in the 'old school medicine' sense. The following figure illustrates the relationships among care pathways, the existing openEHR Entry types and Task Plans. 

[.text-center]
.openEHR Planning Artefact Relationships
image::diagrams/planning_artefacts.svg[id=planning_artefact_relationships, align="center", width=60%]

In simple cases, a Task Plan may just be the list of Tasks to fulfill one order, i.e. a single `INSTRUCTION` prescribing a course of antibiotics. The general case however is that the Task Plan corresponds to a clinical goal which implicates multiple orders, such as the CHOP chemotherapy mentioned above. 

Consequently, _not every Task in a Task Plan is associated with an order_, illustrated by the yellow Task objects in the above figure. While a typical case is that a Task corresponds to an openEHR `ACTION` that has not yet been recorded (and which normally has a driving `INSTRUCTION`), it may also correspond to an `ACTION` that has no `INSTRUCTION` or indeed an `OBSERVATION` or possibly an `EVALUATION` (perhaps some kind of check during a procedure). Indeed, there is also no reason why a Task Plan cannot consist of Tasks that define administrative work and would be documented with openEHR `ADMIN_ENTRYs`.

We can infer from the above that the main driver of a Task Plan isn't in general an order, but a care plan or guideline that usually includes orders, or else plain old ad hoc planning.

A high-level view of how clinical work generates openEHR information can be visualised conceptually with a modified version of the {openehr_rm_ehr}#_information_ontology[Clinical Investigator process diagram] as follows:

[.text-center]
.Clinical Investigator Process with Planning
image::diagrams/clinical_process_planning.svg[id=clinical_process_planning, align="center", width=70%]

According to this scheme, `TASK_PLAN` and `TASK` are new types of information that can be committed to the EHR.

== Order Semantics versus Plan Semantics

Despite the above explanation, the difference between Instructions (as defined in openEHR) and Task Plans may not be completely clear. However, there is a key difference, which is the semantic level at which the two are expressed. A typical order, represented in an openEHR `INSTRUCTION` has an _algorithmic_ form, such as  "Amoxicillin 3 times a day, orally, for 7 days". Although healthcare professionals do not typically think about it, this expression is in fact a small program that is mentally _interpreted_ to produce resultant actions such as giving one tablet at 9:15 am, one at lunch and so on.

We can think of a Task Plan for ordered actions as the interpreted form of the original order statement(s), that is to say, a completely 'unfolded' list of single Tasks in time such as 'give 1 Amoxycillin oral tab at lunch'. This is a form suitable for displaying on work lists, checking off and ensuring no mistakes are made. When a Task is performed, it will still give rise to the appropriate openEHR Entry recording the details, such as 'gave 1 Amoxycillin tab at 13:37'.
